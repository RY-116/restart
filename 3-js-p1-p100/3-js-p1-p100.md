## P1

宣传，无视即可



## P2

学完这个可以无缝对接到Nodejs Vue React 小程序的视频



## P3

js：

1. ECMAScript：核心语言功能
2. DOM文档对象模型：操作网页内容
3. BOM浏览器对象模型：与浏览器交互



## P4

经典的`alert()`和`console.log()`



## P5

JS的三种：

1. 行内式：

   `<a href="javascript:alert('ssssss')">aaa</a>`

   真的会有人写这玩意么（

2. 内嵌式

   `<script></script>`建议放在`<body>`的最后面

3. 外部：

   `<script src="js/hello.js"></script>`

   只要引入了外面的js文件，在这对标签里面再写js代码就没用了

   注：可以引入多个js文件，多写几对script标签即可

   

## P6

ES6建议我们**不用再加分号**了



## P7

变量



## P8

变量名只能有数字，字母，_，$，严格区分大小写且只不可以以数字开头

建议驼峰命名



## P9

数据类型

1. 基本数据类型
   1. Number：科学计数法也可以写如2e3=2000，各种其它进制也可以，NaN（Not a Number）也是数值类型
   2. String
   3. Boolean
   4. Undefined：声明但是未定义，以后给它赋值什么类型都行
   5. Null：以后这个变量会被赋值为对象，但是现在暂时没有，就是Null
   6. Symbol：放在ES6里面再说
2. 复杂数据类型
   1. 对象
   2. ...



## P10

`typeof 变量`可以判断变量类型



## P11

数据类型转化——转数值

`Number()`强制转为数值

`Number("123aaa")`结果是NaN

`Number(null)`结果是0

`Number(undefined)`结果是NaN



`parseInt()`要宽松一些

`parseInt("123abc")`结果为123

`parseInt("123.45")`结果为123（毕竟是转为Int）



`parseFloat()`更宽泛一点

`parseFloat(123aa)`结果为123



还可以用除了加号的运算符来将变量转为数值类型

`"2"*3`结果是6



> 用处：比如要取出盒子宽度123px



## P12

数据类型转换——转字符串

`String()`显然可以



`变量.toString()`大部分情况也可以，但是Undefined和Null无法转换



+也可以，如`100+""`



## P13

数据类型转换——转布尔类型

`Boolean()`：

1. ""，0，null，undefinied，NaN：false
2. 其余：true



## P14

数学运算符

`10/6 = 1.666666667`

取整还得再用`parseInt()`



## P15

赋值运算符

`%=`少见捏



## P16

`==`

`===`

`!=`（这玩意有点绕，不如转换类型用`!==`）

`!==`



## P17

逻辑运算符

经典与或非`&&`，`||`，`!`



一些小细节：

1. `!!a`将a转换为布尔值

2. `&&`和`||`有短路效果
3. `x && x.toString()`可以防止因为x是undefinded或者null导致程序中断
4. `x || "这里可以写点东西"`可以使得啥都不输入时显示默认文本，当然也可以在接受输入传给后端时候用



## P18

自增自减运算符



## P19

三元运算符

可以单独写一行用如

`a > 10 ? aaa() : bbb()`

三元运算符也可以嵌套



## P20

if



## P21

if案例



## P22

```js
switch (a) {
    case 111:
        ...
        break;
    case 222:
        ...
        ...
    default:
        ...
}
```

用来判断状态码很不错

注意switch是严格匹配，类型不同记得转换



## P23

switch案例



## P24

while

> chrome的检查-源代码窗口是可以打断点调试的



## P25

while案例



## P26

dowhile

先执行一次，再进行条件判断



## P27

dowhile案例



## P28

for



## P29

for案例



## P30

break和continue



## P31

案例



## P32

还是简单案例捏



## P33

函数

```js
function fn(){
    ...
    声明式的可以先调用再定义
}
var fn2 = function(){
    ...
    赋值式的不行
}
```



## P34

函数的简单案例



## P35 

形参和实参

传参传少了，少的参数就是undefined

传参穿多了，多传的参数没有人管



## P36

参数案例

咕咕咕



## P37

函数返回值



## P38

return案例

引入js文件后，里面的方法函数啥的都可以直接用

```html
<script src="..."></script>
...
<script>
直接用就行
</script>
```



## P39

函数预解析

js是解释型语言，先将代码进行通读和解释，然后再执行

解释代码，也就是预解析时，解释了两个东西：

1. 声明式函数：声明某个函数名及其函数内容
2. `var`：声明有一个变量

> 赋值型函数之所以不能先调用再定义，是因为被提升到代码最前面的只有变量声明而没有函数定义，你当然不能调用一个变量

也叫**变量提升**

注意：被提升到代码顶部的有var声明的变量以及**整个声明式函数**

注意：变量提升只在一组script标签内进行，多组script互不影响（但是互相可以访问，这是没有影响的）

注意：显然，函数内部的变量提升只会提升到函数作用域的最上方



## P40

重名的两个变量或两个函数，显然后面定义的会覆盖前面的

如果出现了变量和函数重名

```js
var age = 100;
function age(){
    console.log(111)
}
console.log(age) // 100

// var age被提升到最上面，然后function age(){console.log(111)}被提升到第二层，然后age=100，然后console.log(age)，此时自然age是100
```



## P41

作用域

在JS中**只有函数能生成局部作用域**



## P42

变量赋值时，会先在自己作用域内部寻找，如果找不到该变量，那么就一级级往外找，如果一直找到全局作用域都没有，**那么就把这个变量定义为全局变量**并赋值



## P43

对象数据类型：键值对的集合

创建对象：

1. 使用字面量的方式：`var obj = {}`
2. 使用内置构造函数：`var obj = new Object()`



## P44 

增加属性，除了`obj.name = "aaa"`外，还可以用

`obj["name"] = "aaa"`（先增加了属性name，再给它赋值）（如果name不加双引号，那显然就是一个变量——或许这可以给对象动态地添加不同的key）

显然，`obj.name`和`obj["name"]`等价



删除对象中的属性：

`delete obj.name`



另外，对于一些不符合变量命名规则的key比如

```js
var obj = {
    "a+b": 111111
}
```

显然只能用`obj["a+b"]`来取出



## P45

遍历对象

```js
for (var i in obj) {
    // i是key
    // obj[i]是value
    // 显然此时点操作符就没法用了
}
```



## P46

简单数据类型放在栈

复杂数据类型放在堆，它们在堆里的地址被放在栈里（？）

深拷贝和浅拷贝



## P47

复杂数据类型：对象，函数，数组，...

创建数组：

1. 字面量：`var ageArr = [1, 2, 3, 4]`

2. 构造函数：`var arr1 = new Array()`

   传入多个参数就是在初始化数组，传入一个数字就是在设置数组长度



## P48

JS中的数组天生就是弹性数组



`arr.length = 0`可以清空数组

如果数组只有3个元素，设置`arr[4] = 1`，那么`arr[3]`会被空着



## P49

冒泡



## P50

选择排序

每次循环把剩下的无序部分的最小值交换到最前面变成有序部分的一部分



## P51

数组常用方法：

1. `arr.push()`：向数组后面追加元素，返回值是追加完元素后数组的长度

2. `arr.pop()`：弹出最后一个元素，返回值是弹出的元素

3. `arr.unshift()`：向数组前面追加元素，返回值是追加完元素后数组的长度

4. `arr.shift()`：弹出第一个元素，返回值是弹出的元素

5. `arr.splice(index, num, value)`：从index索引开始删除num个元素，然后加上value元素，value可以写多个元素，逗号分割即可，返回值是被删掉的元素组成的数组（num设置为0即可当成插入元素）

   如`arr.splice(1, 0, "aa", "bb")`是在索引1的地方插入两个元素，插入后"aa"的索引是1

6. `arr.reverse()`：数组倒序

7. `arr.sort()`：排序（需要回调函数当参数）

   ```js
   arr.sort(function(a,b) {
       return a-b
   })
   // 从小到大排序
   ```



## P52

不影响原数组的方法

1. `var newArr = arr1.concat(arr2， xxx)`：拼接数组，xxx可以多个，也会被拼接到后面

   `var arr1 = arr4.concat()`：复制arr4给arr1

2. `arr.join(str)`：数组中元素通过str连接变成一个大字符串返回

3. `arr.slice(start, end)`：截取从索引start到索引end-1的数组（end可以是负数），如果只有一个参数，表示截取从索引到最后的数组

   `var arr1 = arr4.slice()`：这也是数组复制

4. `arr.indexOf(value, index)`：从索引index开始往后查找value的索引，-1表示没查到
5. `arr.lastIndexOf(value, index)`：从索引index从后往前查，-1表示没查到



## P53

数组去重

1. 遍历数组，使用`indexOf()`判断值是否在新数组中存在，如果没有则把值放入新数组

2. 使用对象，将数组中的值作为对象的key，最后遍历对象key即可

3. 使用集合

   ```js
   var set1 = new Set(arr)
   var arr1 = Array.from(set1)
   ```



## P54

还有一些数组方法

1. `forEach`：遍历

   ```js
   arr.forEach(function(item, index, arr){
       // item是元素，index是索引，arr是原数组
   })
   ```

2. `map`：映射

   ```js
   var arr2 = arr1.map(function(item){
       return item * item // 映射为平方
   })
   ```

3. `filter`：过滤

   ```js
   var arr2 = arr1.filter(function(item){
       return item > 100
   })
   ```

4. `every`：每一个

   ```js
   var arr2 = arr1.every(function(item){
       return item > 90 // arr1中每一个都>90时arr2是true
   })
   ```

5. `some`：任意一个

   ```js
   var arr2 = arr1.some(function(item){
       return item > 90 // arr1中只要有>90的元素arr2就是true
   })
   ```

6. `find`：搜索

   ```js
   var arr2 = arr1.find(function(item){
       return item.age === 20
       // 找出第一个岁数是20的
   })
   ```

7. `reduce`：叠加

   ```js
   var arr = [1, 2, 3, 4, 5]
   arr.reduce(function(prev, item){
       return prev + item
       // prev是上一次的结果，item是元素，0是初始值，一开始prev是初始值0
       // 实现了累加
   }, 0)
   ```

   

## P55

