## P101

鼠标的事件对象属性分析

1. `clientX` `clientY`：距离浏览器可视窗口左上角的坐标值

   如果滚动了页面，显然可视窗口会改变，该属性值也会变

2. `pageX` `pageY`：距离文档左上角的坐标值

   不会改变

3. `offsetX` `offsetY`：距离触发事件的元素的左上角的坐标值



## P102

案例 鼠标跟随

p102.html

```js
    box.onmousemove = function(evt) {
        this.firstElementChild.style.left = evt.offsetX + "px"
        this.firstElementChild.style.top = evt.offsetY + "px"
    }
// 这里会出现的问题是，鼠标抖动到p标签上时，offsetX和Y就会变成相对于p元素计算，显然此时就会变成0，因此会出现不停闪的现象

// 解决方法1
// 设置p标签离鼠标远一点即可
    box.onmousemove = function(evt) {
        this.firstElementChild.style.left = evt.offsetX + 50 + "px"
        this.firstElementChild.style.top = evt.offsetY + 50 + "px"
    }

// 解决方法2
// 给p标签设置样式 pointer-events: none
```



## P103

案例 鼠标拖拽

p103.html



## P104

DOM事件流

**当元素触发一个事件时，其父元素也会触发相同的事件，再往上的父元素等都会触发这个事件**

无论父元素有没有设置这个事件，事件都会一层层往上传播

![](../img/4-1.png)



标准的dom事件流：

捕获：window => document => body => outer

目标：inner

冒泡：outer => body => document => window

但是默认情况下，事件**只会在冒泡阶段触发**

要想触发捕获阶段的事件处理函数，需要使用dom2进行绑定并配置（很少用）

`outer.addEventListener("click", function(){}, true)`该事件会在捕获阶段触发（ie678不兼容，只能用默认情况）



事件流永远是这样走，区别只是每一层有没有监听事件

> 注意：事件传播是往父元素方向传播，和实际上盒子的位置无关，就算你定位到了一个空白的地方，事件照样会传给父元素



## P105

阻止事件传播

```js
box.onclick = function(evt) {
    ...
    evt.stopPropagation() // 停止冒泡，阻止事件传播
    
    // ie 678 不支持这个，需要用下面这个
    // 虽然现在已经没有人用ie 678了
    evt.cancelBubble = true
}
```



## P106

阻止默认行为

在dom0中，只需要在要阻止默认行为的事件处理函数中加上`return false`即可，如

```js
document.oncontextmenu = function(){
    ...
    return false
}
```

即可阻止浏览器自带的右键菜单



在dom2中需要用这种方法

```js
document.addEventListener("contextmenu", function(evt){
    evt.preventDefault() // 阻止默认行为
    // ie 678 还是有兼容性问题，需要改成下面这个
    evt.returnValue = false
})
```



## P107

案例 自定义右键菜单

p107.html

感觉还不错



## P108

事件委托：把子元素要触发的事件委托给父元素去做

由于冒泡机制，子元素触发事件时，父元素也一定会触发相同事件，因此事件委托是可行的

此外，我们还需要让父元素知道到底是哪个子元素触发了事件

事件对象中有属性`target`，表示触发事件的是哪个元素

（还是ie678，需要换成`evt.srcElement`，所以或一下就行）



比如上面的右键自定义菜单，就可以让父元素ul去处理每个li触发的事件，这样可以减少多个函数绑定的性能损耗，并且适配性更好，以后再加新的节点的话，有可能就可以直接适配上去



## P109

正则表达式 

创建方式：

1. 字面量：`var reg = /abc/`要求有连续的abc存在
2. 内置构造函数：`var reg = new RegExp("abc")`

```js
username.onblur = function(){
    reg.test(this.value)
}
```



## P110

元字符——基本元字符

1. `\d`：一位数字
2. `\D`：一位非数字
3. `\s`：一位空白，包括空格缩进换行
4. `\S`：一位非空白
5. `\w`：一位字母/数字/下划线
6. `\W`：一位非字母/数字/下划线
7. `.`：任意内容（换行除外）
8. `\`：转义符



## P111

元字符——边界符

1. `^...`：以...开头
2. `...$`：以...结尾

所以开头结尾都限制就是`^...$`



## P112 

元字符——限定符

1. `...*`：...重复0-多次
2. `...+`：...重复1-多次
3. `...?`：...重复0-1次
4. `...{n}`：...重复n次
5. `...{n,}`：...重复至少n次
6. `...{n,m}`：...重复n到m次

> 限定符只会修饰前一个元字符，即`\abc{2}\`相当于`\abcc\`



## P113 

元字符——特殊符号

1. `()`：里面的元字符被视为整体

2. `|`：左或右都行，这个是对左右的两个整体进行或，而不是对一个元字符进行，当然或也可以多个一起用

3. `[]`：代表一个字符，该字符在框里面即可

   `/[abcdef]/`代表是a/b/c/d/e/f的一个字符

   `/[a-zA-Z0-9_]/`等价于`/\w/`

4. `[^...]`：`[]`的取反

## P114

正则表达式 

1. 测试字符串是否符合正则：`reg.test(str)`
2. 捕获字符串中符合正则的部分：`reg.exec(str)`

```js
var datestr = "time is 2022-2-02 12:12:12"
var reg = /\d{4}-\d{1,2}-\d{1,2}/
var resstr = reg.exec(datestr[0]) // 2022-2-02

// 加上括号还会有单独捕获的内容
var reg2 = /(\d{4})-(\d{1,2})-(\d{1,2})/
var resstr = reg.exec(datestr)
// resstr[0] : 2022-2-02
// resstr[1] : 2022
// resstr[2] : 2
// resstr[3] : 02
```

注意，`reg.exec()`只会从字符串开头进行匹配，并且匹配到第一个符合条件的结果就会返回，返回值为数组，数组第一项为匹配到的内容

解决方法如下



标识符

1. `/.../g`：全局

   设置后，第二次进行捕获时会跳过第一次捕获的内容往后继续捕获，如果不设置那么无论捕获多少次，最终的结果都是第一个被捕获的内容

2. `/.../i`：忽略大小写



## P115

正则表达式的两个特性

1. 懒惰：exec只会从字符串开头进行匹配，并且匹配到第一个符合条件的结果就会返回，无论捕获多少次都是这个流程，不会往后走，解决方法上面说过了

2. 贪婪：exec尽量多地匹配，如`/\d{1,4}/`能匹配到4个数字那就会匹配4个，不会匹配1个就收手

   非贪婪模式：`/\d{1,4}?/`会尽量少的进行捕获，这个模式可以在以下元字符中使用`*`，`+`，`?`，`{n,}`，`{n,m}`

   ```js
   var str = "<p class="pp"><span>aaaa</span></p>"
   var reg = /<p.*?>/
   reg.exec(str) // 能取出<p class="pp">
   ```

   

## P116

正则与字符串方法

```js
var str = "adearga"
var newstr = str.replace(/a/g, "*")
// 正常的replace只会替换第一个
// 这样可以将全局的a全部替换成*

str.search(/a.*a.*a/) // search也可以传正则

str.match(/.../g) // 一般都是传正则进行匹配
```



## P117

案例 密码强度验证

> 一般的验证密码邮箱手机号身份证啥的正则可以直接百度



## P118

除了es6箭头函数外，谁调用，this指向谁

```js
function test(){
    console.log(this) // window
}
// 全局函数是挂在window上的
// test()其实是window.test()
// 全局变量也是

var obj = {
    name: "111",
    test: function(){
        console.log(this) // obj
    }
}

setTimeout(function(){
    console.log(this) // window
}, 2000)
setIntervalout(function(){
    console.log(this) // window
}, 2000)
// 定时器延时后是被window调用的

box.onclick = function(){
    console.log(this) // box
}
// dom2里面也一样
```



## P119

改变this指向的三个方法

```js
var obj1 = {
    name: "obj1",
    getName: function(){
        console.log("111" + this.name)
    }
}
var obj2 = {
    name: "obj2",
    getName: function(){
        console.log("222" + this.name)
    }
}

obj1.getName.call(obj2) 
// 执行obj1的getName函数，并将obj1中getName方法中的this指向obj2
// 输出111obj2

obj1.getName.apply(obj2) 
// 执行obj1的getName函数，并将obj1中getName方法中的this指向obj2
// 输出111obj2

// 这两个方法的区别在于，如果obj1.getName函数需要传入多个参数，那么这两个方法写参数的格式不同
obj1.getName.call(obj2, 1, 2, 3)
obj1.getName.apply(obj2, [1, 2, 3])

var func1 = obj1.getName.bind(obj2) 
// 将obj1中getName方法中的this指向obj2，然后返回这个新函数，不会自动执行
func1()
// 输出111obj2

// 这个方法传参和call一样
var func2 = obj1.getName.bind(obj2, 1, 2, 3) 
```



## P120

ES6定义变量

`let`与`var`的区别：

1. 与`var`相比，`let`没有变量提升，必须先定义再使用

2. 同时，`let`不可以定义同名变量

3. `var`只有在函数作用域中定义的才是局部变量

   ```js
   if (true) {
       var i = 1 // 这也是全局变量
   }
   console.log(i) // 1
   ```

   但是`let`只要在大括号内定义的就是局部变量



`let`与`const`的区别：（首先`const`满足`let`的一切要求）

1. `const`定义的常量不可以重新赋值

   ```js
   const obj = {
       name: "111"
   }
   obj.name = "222"
   // 可以修改，因为obj是存在栈里的地址，对象的内容是放在堆里的
   // 地址没变，也就是obj没有被重新赋值
   ```

2. `const`在定义时必须赋值



## P121

案例 块级作用域



## P122

箭头函数

1. 只有一个形参时()可省略

   ```js
   var func = item => {
       console.log(item)
   }
   ```

2. 只有一句代码或只有返回值时{}可以省略

   ```js
   var func = a => 100 * a // return都能省
   ```

   如果返回的是对象，需要这样防止分不清

   ```js
   var func = () => ({
       name: "111"
   })
   ```

3. 箭头函数没有`arguments`

   ```js
   // 普通函数有
   var func = function(){
       // 没有形参，但是传入的参数会被保存在arguments中
       // arguments是个伪数组
       console.log(arguments[0])
   }
   func(1, 2, 3)
   ```

4. 箭头函数中的this属于它的父级作用域

   ```js
   input.oninput = function(){
       let that = this 
       setTimeout(function(){
           console.log(this) // window
           console.log(that) // input
       }, 1000)
   }
   
   input.oninput = function(){
       setTimeout(() => {
           console.log(this) // input
       }, 1000)
   }
   ```



## P123 

ES6解构赋值：从对象和数组中快速获取里面的

```js
// 数组的解构赋值
let arr = ["aaa", "bbb", "ccc"]
let [x, y, z] = arr
console.log(x, y, z)

let [a] = arr
console.log(a) // aaa

// 多维数组也可以用
let arr2 = [1, 2, [3, 4]]
let [x, y, [z, w]] = arr2

// 经典案例 交换两个数 不能用let因为let不允许重复赋值
var b = 10
var c = 20
var [b, c] = [c, b]
```

不过数组的解构赋值一般不是那么有用，更有用的是对象的

```js
// 对象的解构赋值
let obj = {
    name: "aaa",
    age: 100,
    location: "nanjin"
}
let {name, age, location:myLocation} = obj
// 注意，定义的变量必须与对象中的变量同名
// 如果遇到如location这样已经存在的变量，应该如上解决
// 如果定义的变量不想和对象中的变量同名，也可以这样做

// 多维变量
let obj2 = {
    name: "aaa",
    age: 100,
    location: {
        province: "jiangsu",
        city: "nanjin"
    },
    hobby:[111, 222, 333]
}
let {
    name,
    age,
    location:{
        province,
        city
    },
    hobby:[m, n, k]
} = obj2

// 解构可以直接在形参进行
let obj = {
    name: "111",
    password: 123
}
function func({name, password}){
    ....
}
func(obj)
```



## P124

ES6对象简写

```js
let username = "aaa"
let password = 123
let obj = {
    username: username,
    password: password
}
// 当key和value相同时，可以省略value，变成如下写法
let obj = {
    username,
    password
}

// 同时，对对象内的函数也有简写
let obj = {
    a: 1,
    getName: function(){
        ...
    }
}
// 可以简写成
let obj = {
    a: 1,
    getName(){
        ...
    }
}
```



## P125

ES6展开运算符：`...`

```js
// 1.合并数组
let a = [1, 2, 3]
let b = [4, 5, 6]
let c = [...a, ...b] // [1, 2, 3, 4, 5, 6]

// 2.复制数组
let a = [1, 2, 3]
let b = [...a]

// 3.收集形参
let test = (a, b, ...arr) => {
    // 收集了剩余参数
    console.log(arr) // [3, 4, 5]
}
test(1, 2, 3, 4, 5)

// 4.传实参
let arr = [1, 2, 3]
let test = function(a, b, c){
    ....
}
test(...arr)

Math.max(...arr) // 便捷用法

// 5.伪数组转换
function test1(){
    let arr = Array.from(arguments) // 将伪数组转换为真数组的方法1
    let arr = [...arguments] // 方法2
}
test1(1, 2, 3)
```

不仅能展数组，还能展对象

```js
let obj1 = {
    name: "aa",
    age: 10
}
let obj2 = {
    location: "nanjin"
}

let obj3 = {
    ...obj1,
    ...obj2
}
// 如果有同名属性，则后面会覆盖前面
// 使用场景：修改用户信息
let obj = {
    name: "aa",
    age: 10
}
let newAge = 20
let newObj = {
    ...obj,
    age: newAge
}
```



## P126

ES6模块化语法

非模块化代码有以下问题

1. 私有函数被外界使用
2. 重名
3. 互相依赖混乱



解决问题1：私有函数被外界使用

```js
// ./module/A.js
function A1(){
    ....
}

function A2(){
    ....
}

function A3(){
    ....
}

export {
	A1,
    A2
}
// 导出A1，A2两个函数，此处是对象简写写法

// ----------------------------------------------------

// ./xxx.html
// <script type="module"> </script>
// 注意得改下script的type

import {A1, A2} from './module/A.js'


// 这样就实现了限制外界访问内部，解决了问题1
```



解决问题2：重名

```js
// ./module/A.js
function test(){
    ....
}
export {
	test
}

// ./module/B.js
function test(){
    ....
}
export {
	test
}

// ./module/xxx.html
import {test as A_test} from './module/A.js'
import {test as B_test} from './module/B.js'

// 这样就就通过重命名解决了重名问题
```



解决问题3：依赖混乱

```js
// ./module/A.js
function A1(){
    ....
}
export {
	A1
}

// ./module/B.js
import {A1} from './A.js'
A1()

// 这样即使B.js先于A.js引入也不会产生依赖错误
```



一些另外的小细节

```js
// ./module/C.js
function C(){
    ....
}
export default C
// 如果只有一个函数要导出，就可以这样写，表示默认导出C


// ./xxx.html
import CCCC from './module/C.js'
// 因为只有一个函数被导出，这里可以随便命名来导入
```



## P127

