## p1

Kerwin老师真容.jpg



## p2

Vue（中二）地图



## P3

Vue专治各种DOM不服



## P4

> 一开始是从Vue2开始讲起

Vue2的引入方式

```html
<script src="....."></script>
<body>
    <div id="box">
        {{10 + 20}}
        {{ myname }}
    </div>
    <script>
    	let vm = new Vue({
            el: "#box", // element，表示#box被纳入Vue管辖
            data: {
                myname: "rr" // 这个叫做 状态
            }
        })
        vm.myname = "kk" // myname实际上是被挂在vm下
    </script>
</body>
```

原来想改myname内容需要找到节点然后修改，现在只需要修改状态即可



## P5

拦截原理

```js
let obj = {
    
}

Object.defineProperty(obj, "myname", {
    // 对obj对象定义了一个myname属性，该属性被获取或者赋值时会走以下两个方法
    get: function(){
        return box.innerHTML
    },
    set(value){
        // value是被赋的值
        box.innerHTML = value
        // Vue修改状态就能修改节点内容的原理大概就是这样
    }
})
```

这是Vue2中使用的拦截原理，它的缺点如下

1. 无法监听ES6的Set，Map变化
2. 无法监听Class类型数据
3. 无法监听属性的新增和删除
4. 无法监听数组元素的增加和删除

因此，在Vue3中，我们使用ES6 Proxy来代替它（IE不支持这个，所以如果Vue3检测到IE，会自动降级为Vue2的监听系统）



## P6

Vue模板语法

```html
<div id="box">
    {{10>20?'aaa':'bbb'}}
    // {{}}里面支持表达式
    <div :class="whichcolor"></div>
    // :表示绑定变量(也支持表达式)
    <div :class="isColor?'aaa':'bbb'"></div>
    // 其实一般如果要改class的话是这样改，里面显然isColor是变量
    
	<button @click="handleChange()"></button>
    // @表示绑定事件
	// JS里面学的各种事件都可以类似地加上来，如@mouseover
</div>
```



```js


let vm = new Vue({
    el: "#box",
    data: {
    	myname: "rr",
        whichcolor: "aaa",
        isColor: true
	},
    methods: {
        handleChange(){
            this.myname = "aa"
            this.whichcolor = "bbb" // 修改class也很容易
            this.isColor = !this.Color
        }
    }
})

```



## P7

指令：

1. `v-show`：`<div v-show="isShow"></div>`，isShow为data中定义的状态，这个指令用于控制节点的动态显示和隐藏

2. `v-if`：和上面类似，用于控制节点动态创建和删除

   > `v-if`比`v-show`懒惰：当都为false时，`v-show`的节点其实已经创建好了，只不过加上了`display: none`，而`v-if`等到设置为true时才会创建节点（`v-if`再设置为false的话节点会被删除）

3. `v-for`：列表渲染指令

   ```html
   <ul>
       <li v-for="item in list">
       	{{item}}
       </li>
   </ul>
   
   <ul>
       <li v-for="(item, index) in list">
       	{{item}}-{{index}}
           // 还能拿到索引
       </li>
   </ul>
   ```

   ```js
   new Vue({
       el: ....,
       data: {
           list: [1, 2, 3, 4]
       }
   })
   ```

4. `v-bind`：动态绑定属性指令，`v-bind:src`等价于`:src`

5. `v-on`：动态绑定事件指令，`v-on:click`等价于`@click`

6. `v-model`：双向绑定表单value（上面两个都是单向绑定）

   `<input type="text" v-model="mytext"></input>`



## P8

案例 todolist 

> ```html
> <ul v-show="list.length">
>     <li v-for="(item, index) in list">
>         {{item}}
>         <button @click="handleChange(index)">
>             del
>         </button>
>     </li>
> </ul>
> ```
>
> ```js
> new Vue({
>     el: ....,
>     data:{
>     	list: [1, 2, 3, 5]
> 	},
>     methods: {
>         handleChange(index){
>             this.list.splice(index, 1)
>         }
>     }
> })
> ```



## P9

v-html

```html
<div id="box">
    {{mytext}}
    // 这里不会解析出标签，为了防止跨站脚本攻击XSS
    <div v-html="mytext">
        // 这里会解析成标签，注意一般只对受信任的来源如后端使用
    </div>
</div>
```

```js
new Vue({
    el: "#box",
    data: {
        mytext: "<b>kkkk</b>"
    }
})
```



## P10

案例 点击高亮

```html
<ul>
    <li v-for="(item, index) in list" :class="current === index ? 'active': ''">
    	{{item}}
    </li>
</ul>
```

如果当前点击的是该盒子，则设置样式高亮



## P11

Vue2的class&style

上面用三目运算符显然无法解决大多数关于修改类的问题，比如同时需要修改多个类名，`class="aa bb"` => `class="cc bb dd"`

动态切换class：

1. 对象方法：

   ```html
   <div :class="classobj">
       
   </div>
   ```

   ```js
   let vm = new Vue({
       el: "#box",
       data: {
           classobj: {
               aa: true,
               bb: true,
               cc: false
           }
           // 这里的aa bb cc是类名
       }
   })
   ```

   想要切换class只需要设置classobj属性的true和false即可

   清晰明了

   但是也有问题

   如果我们`vm.classobj.dd = true`，那么这个新增的属性不会被拦截，没有get和set方法，也就无法正常使用（Vue2只会给初始化时候的属性加上拦截，它无法监听属性的新增和删除）

   Vue2的解决方法：亡羊补牢

   > `Vue.set(vm.classobj, "dd", true)`给classobj对象增加dd属性，初始化为true并添加拦截

   Vue3的解决方法：Vue3支持动态添加属性的拦截，什么都不用做

2. 数组方法：

   ```html
   <div :class="classarr">
       
   </div>
   ```

   ```js
   let vm = new Vue({
       el: "#box",
       data: {
           classarr: ["aa", "bb"]
       }
   })
   ```

   尝试新增数组元素`vm.classarr.push("dd")`，发现有效，但是实际上Vue2无法监听数组元素的增加和删除，之所以这里有效是因为Vue2重写了push方法，加入了监听

   Vue3显然也不会有这样的问题



动态切换style：

1. 对象方法：

   ```html
   <div :style="styleobj">
       
   </div>
   ```

   ```js
   new Vue({
       el: "#box",
       data: {
           styleobj: {
               backgroundColor: 'red'
           }
       }
   })
   ```

   和上面的class相同，也不支持动态添加属性，解决方法也和上面相同

2. 数组方法：

   ```html
   <div :style="stylearr">
       
   </div>
   ```

   ```js
   new Vue({
       el: "#box",
       data: {
           stylearr: [{backgroundColor: 'red'}]
       }
   })
   ```

   一样的

​	

## P12

Vue3的class&style

> Vue3和Vue2的初始化方法不同：
>
> Vue2面向对象式
>
> ```js
> new Vue({
>     el: "#box",
>     data: {
>         myname: "aaa"
>     }
> })
> ```
>
> Vue3函数式
>
> ```js
> let obj = {
>     data(){
>         return {
>             myname: "aaa"
>             // 写在返回值中是因为，如果有两个组件，即使变量名称相同也不会冲突
>         }
>     },
>     methods: {
>         handleChange(){
>             console.log(this.myname)
>         }
>     }
> }
> Vue.createApp(obj).mount("#box") // 挂载到box节点上
> ```
>
> **从Vue2到Vue3，上面学的其它东西都不变**
>
> 

Vue3支持动态添加对象属性和数组元素，实现上一节的操作完全没有问题



## P13

条件渲染 v-if

使用场景：如后端返回商品数据，其中state表示商品状态如已支付，未发货等

```js
new Vue({
    el: "",
    data: {
        datalist: [
            {
                title: "1111",
                state: 0
            },
            {
                title: "2222",
                state: 1
            },
            {
                title: "3333",
                state: 2
            },
            {
                title: "4444",
                state: 3
            }
        ]
    }
})
```

```html
<ul>
    <li v-for="item in datalist">
        {{item.title}}
        <span v-if="item.state===0">未支付</span>
        <span v-else-if="item.state===1">已支付</span>
        <span v-else-if="item.state===2">未发货</span>
        <span v-else>已发货</span>
    </li>
</ul>
```



想让多个盒子同时受控制：

```html
<div>
    <template v-if="isTrue">
    	<div>1</div>
        <div>2</div>
        <div>3</div>
    </template>
</div>
```

template是包装标签，不会出现在页面上，不会破坏DOM结构

当然这里template也可以使用div，但是如果使用div就会破坏外层div和内层div的父子关系



## P14

列表渲染 v-for

`<div v-for="item in list"></div>`等价于

`<div v-for="item of list"></div>`



> `<li v-for="(item, key) in obj"></li>`
>
> 你甚至可以用v-for遍历对象，其中key是键，item是值
>
> （虽然这没有意义
>
> （数组其实也是对象



```html
<ul>
    <li v-for="item in 10"></li>
    // item从1到10
</ul>
```



## P15

v-for中的key值

假设我们要用v-for去渲染一个li

首先有一个列表`[111, 222, 333]`，然后Vue会先创建一个虚拟DOM节点

> 虚拟DOM节点：用JS对象描述的节点
>
> 类似这样
>
> ```js
> [
>     {
>         tag: 'li',
>         text: 111
>         children: [......]
>     }
> ]
> ```

接着，Vue会根据虚拟DOM节点去创建真实的DOM节点，二者是一一映射的关系

然后我们删去列表中的一个元素，现在列表变成了`[111, 333]`

于是Vue会再去创建一个新的虚拟DOM，然后和老的虚拟DOM进行对比，将差异处标记出来形成一个补丁，最后更新到真实DOM中

> 为什么要创建虚拟DOM去对比：因为创建真实DOM的代价很大，一个真实节点里面有很多很多属性，但是虚拟DOM节点就不需要有这些属性，只要有核心属性即可

> 新老虚拟DOM是如何进行对比的：key相同的进行对比
>
> 因此，我们不应该把key设置为index，如果设置为index，那么当我们从中间删去某个元素时，对比的时候后面就会错开导致对比出很多无用的差异
>
> ```html
> <li v-for="(item, index) in list" :key="item.id"></li>
> ```
>
> 理想的key是使用唯一不重复的id
>
> key的作用：跟踪节点的身份，从而重用和重新排序现有元素
>
> 因此，以后使用v-for时不管用不用到**必须加上合理的key**，这是为了以后Vue能复用老的节点，用最小的代价去更新节点



> 先通过Object.defineProperty方法设置拦截，属性修改时通过set方法通知watcher，watcher收录着所有用到该属性的组件，然后创建新的虚拟DOM和老的进行对比，用最小的代价对真实DOM进行更新



> 虚拟DOM => virtual dom / vdom
>
> 虚拟节点 => virtual node / vnode



## P16

检测数组变动

[在Vue2中]

大部分修改原数组的方法都会被检测到并更新页面

（虽然实际上它们都没有被拦截，只是被Vue重写了方法顺便通知页面更新）

但是下面这个完全就检测不到

`vm.list[0] = "111"`

Vue2的解决方法

1. `vm.list.splice(0, 1, "aaa")`在索引0删除一位再添加一个，强行使用方法
2. `Vue.set(vm.list, 0, "aaa")`

**注意，在Vue3中完全没有这种问题，可以随便改**



## P17

案例 模糊查询

```js
// arr: ["aaa", "abc", "ccc"]
let newArr = arr.filter(item => item.includes("a"))
// 过滤出包含a的
```



## P18

案例续

```html
<div id="box">
    <input type="text" :v-model="mytext"/>
    <ul>
        <li v-for="item in search()" :key="item">
        	{{item}}
        </li>
    </ul>
</div>
```

```js
new Vue({
    el: "#box",
    data: {
        mytext: "",
        datalist: ["aaa", "bbb", "abc"]
    },
    methods: {
        search(){
            return this.datalist.filter(item => item.includes(this.mytext))
        }
    }
})
```

**包括{{}}，里面其实都是可以放函数的**，值就是函数返回值

> mytext的改变被拦截，使用到它的search函数也会重新执行一次

> 状态改变，不仅相关的DOM节点会更新，用到的函数也会重新执行



> ```html
> <li v-for="item in search()" :key="item">
> 	{{item}}
> </li>
> ```
>
> （下面P27学了计算属性后知道，这里不应该放方法，应该改成计算属性）



## P19

事件处理器

1. 函数表达式：`@click="func()"`
2. 函数名：`@click="func"`
3. 直接写表达式：`@click="count++"`

这两种都可以，区别在于如果用`func`不加小括号，那么会自动有一个参数evt表示事件对象，`evt.target`就是事件绑定的那个元素，而如果是`func()`，那不写参数就是没有参数

另外，如果想要自己传参那只有用函数表达式方法，如果即要传参又想拿到事件对象，那么需要`@click="func($event, 1, 2, 3)"`可以得到事件对象event并传入参数1 2 3，并且这个$event是固定的



## P20

事件修饰符 语法糖

`<li @click.stop="func"></li>`

`.stop`表示阻止冒泡



`<ul @click.self="func"></ul>`

`.self`表示不会被子元素冒泡触发



应用场景：比如点击按钮弹出一个输入框，同时四周背景变成暗色，点击四周背景会关闭弹出框

实现方法是点击按钮出现一个和界面一样大的透明暗盒子，然后再在中间出现一个包含输入框的盒子，现在的问题是你点击输入框时由于冒泡也就相当于点击了透明暗盒子，导致它连着输入框盒子一起被隐藏

显然这里需要设置阻止冒泡



还有几个不是很常用的修饰符

`.once`只能触发一次

`.prevent`阻止默认行为，如`<a href="xxx.com" @click.prevent="func"></a>`可以避免点击后直接跳转走



## P21

按键修饰符 也是语法糖

`.enter`：`<input type="text" @keyup.enter="func"/>`就是回车后键盘弹起时触发（不过没有这个我们照样可以从事件对象中拿到keycode然后判断是不是回车）

`.esc` `.up` `.down` `.left` `.right` `.space` `.ctrl` `.shift`  `.delete`等常见的都有

并且可以连着写，如`@keyup.enter.ctrl`是在同时按下ctrl和回车键盘弹起后触发

其它的按键也可以绑，只需要知道它的keycode就行如`@keyup.13`



## P22

表单控件绑定（Vue在富表单应用中能大大提升效率）

1. 单个多选框

   ```html
   <input type="checkbox" v-model="isRemember"/> 记住用户名
   ```

   ```js
   new Vue({
       el: "#box",
       data: {
           username: localStorage.getItem('username'),
           isRemember: false
       }
   })
   ```

2. 多个多选框

   ```html
   <input type="checkbox" v-model="checkList" value="vue"/> vue
   <input type="checkbox" v-model="checkList" value="react"/> react
   <input type="checkbox" v-model="checkList" value="wx"/> wx
   ```

   ```js
   new Vue({
       el: "#box",
       data: {
           checkList: []
       }
   })
   ```

   value和实际多选内容不需要一样，当被勾选后checkList中就会出现被勾选项的value

3. 单选框

   ```html
   <input type="radio" v-model="select" value="a"/> 男
   <input type="radio" v-model="select" value="b"/> 女
   <input type="radio" v-model="select" value="c"/> futa
   ```

   ```js
   new Vue({
       el: "#box",
       data: {
           select: ""
       }
   })
   ```

   连name也不用设置了，设置同一个v-model就是一组的



> Vue是mvvm类型的框架，特性就是双向数据绑定



## P23

案例 购物车

见 P23.html

> 不能死脑筋，比如多选框的value，我们不一定非得设置成id，如果后面我们不知道里面哪些属性要用到，可以索性设置为整个item



## P24

续

> `for`和`for of`都可以获取元素内容，而`for in`获取的是元素索引
>
> 当然，`list.forEach`获取的也是元素内容

> 再次强调，{{}}里面可以放函数如计算总金额时`{{ sum() }}`
>
> （下面P27学了计算属性后知道，这里不应该放方法，应该改成计算属性）

> Vue是细粒度的数据驱动更新

> Vue的拦截是深度拦截——你改了对象里面的某个属性那么和这个属性这个对象相关的所有地方都会改变



## P25

`<input type="checkbox" v-model="isAll" @click="clickAll"> 全选/全不选`

在click触发时，v-model还没有同步完成，所以会出现问题

所以一般需要用change事件



全选功能看起来简单，但是和其它一堆功能混起来就容易产生很多BUG，建议看看代码



## P26

表单修饰符

众所周知，双向绑定是很勤快的，状态改变瞬间相关的东西都会变

`<input type="text" v-model.lazy="mytext"/>`如果加上这个，那么状态只会在失去焦点时才改变



还有`.number`可以让输入内容变成数字类型（默认是字符串）（没什么用.jpg）

`.trim`去除首尾空格



## P27

计算属性：为了获得一个结果的逻辑应放在计算属性中写



原则：模板不能过重，即DOM中不能写长的逻辑如下面这个

首字母大写`{{ name.substring(0, 1).toUpperCase() + name.substring(1) }}`

而计算属性就可以防止模板过重难以维护，改成如下这样

```html
{{ myComputedName }}
```

```js
let vm = new Vue({
    el: "#box",
    data: {
        name: "rr"
    },
    // 下面这个里面是专门放计算属性的
    computed: {
        myComputedName(){
            return this.name.substring(0, 1).toUpperCase() + this.name.substring(1)
        }
    }
})
```

计算属性与函数职责不同，**计算属性就是为了计算得到一个结果**，而函数用于处理事件等

注意模板字符串中写的计算属性**不能加小括号**，加上小括号就变成方法了，Vue会去方法里面找

尽管使用方法也能得到看上去一样的结果，但是这有个弊端

```html
{{ myComputedName }}
{{ myComputedName }}
{{ myComputedName }}

{{ myComputedName() }}
{{ myComputedName() }}
{{ myComputedName() }}
```

计算属性只会执行一次并存进缓存，再用到会从缓存里拿，而下面的这个方法会执行三次

当然，计算属性的缓存是有依赖的缓存，里面用到的值变了自然也会重新计算

> 计算属性里面只能同步，因为需要立即得到结果



## P28

案例 计算属性

把之前的几个案例里面用的不对的地方改成计算属性

> 但是计算属性没法传参，所以有的时候还是只能用函数



## P29

watch监听

计算属性等需要立刻拿到结果的地方我们无法使用异步代码，如请求后端拿数据

以之前的模糊查询为例，每输入一个字符都需要请求一次后端，这里靠双向绑定和计算属性就无法做到了（因为异步）

我们需要watch来监听状态改变，然后进行处理

```html
<input type="text" v-model="mytext"/>
```

```js
new Vue({
    el: "#box",
    data: {
        mytext: ""
    },
    watch: {
        mytext(newval){
            // newval就是监听到的新值
            // 这里面写异步函数然后去更新其它状态啥的都可以
        }
    }
})
```

这里watch里面的mytext函数监听的就是data中的mytext状态改变，注意名称必须相同

每次mytext值改变，mytext函数都会执行

> data：状态，被拦截
>
> methods：方法，事件绑定，逻辑计算，可以没有return，没有缓存
>
> computed：计算属性，解决模板过重问题，必须有return，重视结果，有缓存，同步
>
> watch：监听，监听值的改变，不用return，异步和同步都可以，重视过程



## P30

fetch-get

> 之前js那一块讲过了不过再听一遍也没关系
>
> 我直接把那一块的笔记搬过来了↓



xhr的API实现非常混乱，因此我们有了fetch

> ajax是异步请求数据，局部更新页面的技术，xhr是它的一种实现，fetch取代的是xhr
>
> 当然也有兼容性的一些小问题
>
> （github上有兼容库polyfill，可以解决兼容问题（用看上去是fetch的方法封装xhr））

fetch是基于promise封装起来的

```js
// GET
fetch(url).then(res => {
    return res.json() // 这个返回的其实也是promise
    // 这个返回的promise解析后是json对象
    // 如果改成res.text()，返回的promise解析后就是json字符串
}).then(res => {
    console.log(res) // 这才得到了res
})

// fetch的问题是需要你自己去处理错误情况
// 如果自己不处理，那么不会走到catch分支
fetch(url).then(res => {
    if (res.ok) return res.json
    else {
        // 拒绝承诺
        return Promise.reject({
            status: res.status,
            statusText: res.statusText
        })
    }
}).then(res => {
    
}).catch(err => {
    
})

// POST
fetch(url, {
    method: "POST",
    header:{
        "content-type": "application/json"
        // 如果是x-www-formurlencoded的话，body里面放的就是类似name=aaa&age=100这种
    },
    body:JSON.stringify({
        username: "aaa",
        password: "123456"
    })
}).then(res => res.json())
.then(res => {
    
})

// PUT
fetch("http:localhost:3000/users/2", {
    // 使用json-server时默认需要这样写，修改的是id为2的内容
    method: "PUT",
    header:{
        "content-type": "application/json"
    },
    body:JSON.stringify({
        username: "aaa",
        password: "123456"
    })
}).then(res => res.json())
.then(res => {
    
})

// PUT会全部覆盖，PATCH只是部分修改

// DELETE
fetch("http:localhost:3000/users/2", {
    // 使用json-server时默认需要这样写，修改的是id为2的内容
    // 写?id=2也行
    method: "DELETE"
}).then(res => res.json())
.then(res => {
    
})
```



## P31

fetch-post

见上面



## P32

fetch应用

> 一个网站，如果检查看到源码只有一点点，那么很明显这是个前后端分离的项目，我们可以尝试去过滤它的fetch&xhr请求，或许能找到后端返回的东西



## P33

axios

> fetch是标准，是可以直接用的，但axios不是，axios是第三方库，是需要下载的，但是Vue推荐我们用这个库

> 不知道怎么下建议去npm搜

```js
axios.get(url).then(res => {
    console.log(res.data)
})
axios.post(url, "name=aaa&age=100").then(res => {})
axios.post(url, {name: "aa", age: 100}).then(res => {})
```

可见axios比fetch要更加简单



## P34

案例 猫眼数据



## P35

过滤器

计算属性无法传参，所以有的地方不得不用函数如

```html
<img :src="handleImgURL(item.img)"/>
```

但是Vue2不愿意这样，它使用过滤器来代替

```html
<img :src="item.img | imgFilter"/>
```

```js
new Vue({....})
Vue.filter("imgFilter", url => {
    return url + "@adaddafv"
})
```

过滤器`a | b | c ...`可以一直连下去，运行方式是将a作为参数放入b中执行，得到的返回值作为参数再放进c执行...如此下去



**虽然但是，视频结尾告诉我们，Vue3不支持过滤器**



## P36

组件定义
